性能测试记录
=====

本文档用于记录`web-performance-comparison`的性能测试过程数据。

# 测试资源

## 宿主机(虚拟机)资源
- CPU : Intel(R) Xeon(R) CPU E5-2609 v3 @ 1.90GHz, 4 core
- 内存 : 16G
- OS : Anolis OS release 8.6
- docker-ce : 20.10.22
- 网卡带宽 : 10000Mb/s

## 客户机(物理机)资源
- CPU : 12th Gen Intel(R) Core(TM) i7-12700H
- 内存 : 32G
- OS : Linux Mint 20.3
- jmeter : 5.1.1
- 网卡带宽 : 1000Mb/s


# 镜像及空闲时容器资源消耗比较

## 镜像大小比较
`web-pm-go`与`web-pm-java`的镜像大小如下所示：
- `172.17.4.86:5000/web-pm-go:0.0.1` : 21.6 MB
- `172.17.4.86:5000/web-pm-java:0.0.1-SNAPSHOT` : 359.3 MB

可以看到，go的镜像明显比java镜像小一个数量级，但这是有原因的。
1. `web-pm-go`在打镜像时，并没有直接使用`From golang`，而是基于`alpine`，将本地编译好的完整二进制文件直接拷贝进去，因此不需要庞大的gcc等编译需要的库。如果基于`From golang`，在docker编译时再执行二进制文件编译的话，那么go的镜像同样也会有几百兆。
2. java的镜像主要是jdk部分较大，原则上运行时不需要整个jdk，可以用jre缩小镜像，甚至根据模块去除没有使用的依赖包，这样镜像能进一步缩小。但缩小java镜像的意义并不是特别大，而保留完整的jdk则更方便使用jdk的工具包对jvm进行检查或调试。

**结论**

一般来说go的镜像要比java镜像小得多，但其实镜像大小的意义并没有那么大，最多上云的时候多耗费一些网络流量和磁盘空间。

## 空闲时资源消耗比较
首先，在docker编排文件中已经限制了`web-pm-go`与`web-pm-java`的资源上限:
```yaml
    deploy:
      resources:
        limits:
          cpus: '4.00'
          memory: 2048M
        reservations:
          memory: 512M
```
两者限制一样，最多使用4颗CPU，内存占用不能超过2G。

在宿主机使用命令`docker stats --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}"`查看容器的资源消耗情况如下:
```
NAME          CPU %     MEM USAGE / LIMIT
web-pm-go     0.00%     13.8MiB / 1GiB
web-pm-java   0.11%     230.5MiB / 1GiB
```
可以看到，空闲时`web-pm-go`基本不消耗CPU资源，内存占用也极小，只有十几兆。而`web-pm-java`则始终有少量的CPU消耗，内存占用也比较大，空闲时就有200多兆。

**结论**

空闲时，`go+gin`的资源消耗远小于`java+springboot`。


# 单纯HttpAPI接口的性能测试
本节测试单纯的，没有任何数据库或磁盘读写的HttpAPI接口：
- web-pm-go : "/asset/query"
- web-pm-java : "/asset/query"

## web-pm-go-asset_query




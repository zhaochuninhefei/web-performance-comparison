性能测试报告
=====

比较gin、springboot以及quarkus在相同硬件环境下的性能表现。
- go + gin + gorm
- java + springboot + mybatis
- kotlin + quarkus + hibernate

# 一、结论
在相同的硬件与数据库环境下，同样的高并发压力下，`go+gin+gorm`的性能表现明显好于`java+springboot+mybatis`的性能表现。
> 也许可以这样描述：如果将并发压力简化为一个正整数`M`，硬件资源简化为另一个正整数`N`，那么`M/N`的值越大，`go+gin+gorm`相比`java+springboot+mybatis`的优势就越明显。

这应该主要是由于golang的goroutine相比java的多线程，能使用更少的CPU提供更高的并发能力。

比较的性能指标包括:
- 单表读写的TPS、响应时间，以及CPU使用率
- 简单HttpAPI(无数据库读写)的TPS、响应时间，以及CPU使用率
- 空闲时的CPU使用率与内存消耗

> 1. 由于服务器与数据库是同一套环境，磁盘IO的影响是一样的，不会对性能比较造成影响，所以测试数据没有列出。
> 
> 2. 内存方面由于数据量并不大，都没有超过1G，对性能测试过程以及测试结论没有影响，所以单表读写与简单API的内存消耗数据没有列出。

## 1.1 单表读写比较
在`500个用户并发 + 每秒1万次请求`的并发压力下，双方的单表读写的性能表现如下所示：

| 项目 | 接口 | web服务CPU使用率 | 数据库CPU使用率 | 响应时间中位数 | 吞吐量 |
| --- | --- | --- | --- | --- | --- |
| web-pm-go | /account/add 插入数据 | 100% | 150% | 78ms | 2137 |
| web-pm-java | /account/add 插入数据 | 150% | 130% | 168ms | 1776 |
| web-pm-go | /account/query 主键查询 | 130% | 160% | 45ms | 4634 |
| web-pm-java | /account/query 主键查询 | 210% | 100% | 101ms | 3713 |

> web服务与数据库部署在同一个4核服务器上，web服务的CPU使用率过高时，会影响到数据库的CPU使用。

## 1.2 简单API比较
在`1000个用户并发 + 每秒10万次请求`的并发压力下，双方表现如下:

| 项目 | CPU使用率 | 响应时间中位数 | 吞吐量 |
| --- | --- | --- | --- |
| web-pm-go | 220% | 23ms | 28386 |
| web-pm-java | 270% | 55ms | 15816 |

## 1.3 空闲比较
空闲时双方的CPU使用率以及内存消耗比较
```
NAME          CPU %     MEM USAGE / LIMIT
web-pm-go     0.00%     36.93MiB / 2GiB
web-pm-java   0.13%     545.9MiB / 2GiB
```

# 二、测试资源与思路
本章节用于记述测试资源与思路。

## 2.1 服务器(虚拟机)资源
web服务器资源
- CPU : Intel(R) Xeon(R) CPU E5-2609 v3 @ 1.90GHz, 4 core
- 内存 : 16G
- OS : Anolis OS release 8.6
- docker-ce : 20.10.22
- 网卡带宽 : 10000Mb/s


数据库服务器资源
- CPU : Intel(R) Xeon(R) CPU E5-2630 v3 @ 2.40GHz, 8 core
- 内存 : 16G
- OS : CentOS Linux release 7.9.2009
- 数据库 : MySQL Community Server 8.0.22
- 网卡带宽 : 10000Mb/s


## 2.2 客户机(物理机)资源
- CPU : 12th Gen Intel(R) Core(TM) i7-12700H
- 内存 : 32G
- OS : Linux Mint 20.3
- jmeter : 5.1.1
- 网卡带宽 : 1000Mb/s

### 2.2.1 客户机socket连接端口配置调整
为防止高并发时jmeter发生`java.net.noroutetohostexception`异常，对客户机进行如下配置:

```sh
# 查看可用端口号范围
# 这里查看的结果是 `32768	60999`
cat /proc/sys/net/ipv4/ip_local_port_range

# 查看端口释放后的等待时间，这里的结果是60秒
cat /proc/sys/net/ipv4/tcp_fin_timeout

# 调低端口释放后的等待时间，改为30秒
echo 30 > /proc/sys/net/ipv4/tcp_fin_timeout

# 释放超时端口给新连接使用，默认为0，修改为1
echo 1 > /proc/sys/net/ipv4/tcp_tw_reuse

# 或在`/etc/sysctl.conf`中加入以下配置:
#  net.ipv4.tcp_tw_reuse=1
#  net.ipv4.tcp_fin_timeout=30
# 然后执行以下命令生效
sudo sysctl -p

```

## 2.3 性能比较思路
分别使用golang和java的流行web框架开发简单的HttpAPI应用，使用JMeter比较它们的性能表现。
> 后续增加了`kotlin + quarkus`

- golang采用`gin + gorm`
- java采用`springboot + mybatis`
- kotlin采用`quarkus + hibernate`

语言、框架与工具及其版本信息如下：
- golang版本 : v1.17.5
- gin版本 : v1.8.1
- gorm版本 : v1.24.2
- java版本 : openJDK-17.0.3
- springboot版本 : 3.0.0
- mybatis-spring-boot-starter版本 : 3.0.1
- JMeter版本 : 5.1.1

做成两个web项目工程，并编译为docker镜像，部署在服务器docker环境上。
- web-pm-go
- web-pm-java

具体代码参考:

<a href="https://github.com/zhaochuninhefei/web-performance-comparison" target="_blank">web-performance-comparison</a>


# 三、镜像及空闲时容器资源消耗比较
本章节对镜像大小，以及空闲时的容器资源消耗进行比较。

## 3.1 镜像大小比较
镜像大小如下所示：
- `web-pm-go:0.0.1` : 26.3 MB
- `web-pm-java:0.0.1-SNAPSHOT` : 366.6 MB
- `web-pm-quarkus:0.0.1` : 164.1 MB

可以看到，go的镜像明显比java镜像小一个数量级，但这是有原因的。
1. `web-pm-go`在打镜像时，并没有直接使用`golang`镜像，而是基于`alpine`镜像，将本地编译好的完整二进制文件直接拷贝进去，因此不需要gcc等编译所需要的庞大的库。如果基于`golang`镜像，在docker编译时再执行二进制文件编译的话，那么go的镜像同样也会有两三百兆。
2. java的镜像主要是jdk部分较大，原则上运行时不需要整个jdk，可以用jre缩小镜像，甚至根据模块去除没有使用的依赖包，这样镜像能进一步缩小。但缩小java镜像的意义并不是特别大，而保留完整的jdk则更方便在容器内使用jdk的工具包对jvm进行检查或调试。

**结论**

一般来说go的镜像要比java镜像小得多，更节省磁盘空间，更节省上传或下载镜像时的流量。

## 3.2 空闲时资源消耗比较
首先，在docker编排文件中已经限制各个容器的资源上限:
```yaml
    deploy:
      resources:
        limits:
          cpus: '4.00'
          memory: 2048M
        reservations:
          memory: 512M
```
限制一样，最多使用4颗CPU，内存占用不能超过2G。

在宿主机使用命令`docker stats --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}"`查看容器资源消耗。

性能测试前的空闲时资源消耗:
```
NAME            CPU %     MEM USAGE / LIMIT
web-pm-go       0.00%     10.12MiB / 2GiB
web-pm-java     0.15%     397MiB   / 2GiB
web-pm-quarkus  0.01%     29.26MiB / 2GiB
```

性能测试刚结束时资源消耗:
```
NAME            CPU %     MEM USAGE / LIMIT
web-pm-go       0.00%     10.12MiB / 2GiB
web-pm-java     0.15%     397MiB   / 2GiB
web-pm-quarkus  0.01%     29.26MiB / 2GiB
```


在性能测试结束后，再查看空闲时的资源消耗，
:
```
NAME            CPU %     MEM USAGE / LIMIT
web-pm-go       0.00%     36.93MiB / 2GiB
web-pm-java     0.13%     545.9MiB / 2GiB
web-pm-quarkus  0.01%     545.9MiB / 2GiB
```
可以看到，空闲时`web-pm-go`基本不消耗CPU资源，内存占用也小，只有几十兆。而`web-pm-java`则始终有少量的CPU消耗，内存占用也较大，空闲时就有几百兆，这是由于springboot在JVM中初始化了大量的javabean。

**结论**

空闲时，`go+gin+gorm`的资源消耗明显少于`java+springboot+mybatis`，特别是内存消耗，少了一个数量级。


# 四、简单API性能测试
本节测试简单的HttpAPI接口，即，没有任何磁盘IO(比如数据库读写)，也没有额外添加拦截器或过滤器。
- web-pm-go : "/asset/query"
- web-pm-java : "/asset/query"
- web-pm-quarkus : "/asset/query"

从结果上看，**高并发场景下的简单HttpAPI，在服务器硬件相同的条件下，相比java+springboot，go+gin使用更少的资源能够提供明显更好的性能表现。**
- CPU使用率上，`web-pm-go`比`web-pm-java`少大约50%，`web-pm-quarkus`的CPU使用率最高。
- 响应时间上，`web-pm-quarkus`最快，`web-pm-go`其次，`web-pm-java`最慢。
- 吞吐量上，`web-pm-go`最高，`web-pm-quarkus`其次，`web-pm-java`最低。

在`1000个并发用户 + 每秒10万次请求`的并发压力下，表现如下:

| 项目 | CPU使用率 | 响应时间中位数 | 吞吐量 |
| --- | --- | --- | --- |
| web-pm-go | 220% | 23ms | 28386 |
| web-pm-java | 270% | 55ms | 15816 |
| web-pm-quarkus | 290% | 17ms | 18879 |

> 这里比较的API都没有多少内存消耗，`web-pm-go`和`web-pm-java`基本都是在空闲时内存消耗的基础上略有增加，但`web-pm-quarkus`在测试期间内存明显增多几百兆，原因不清楚。


## 4.1 web-pm-go-asset_query
该接口完整URL : `http://hostname:18080/asset/query?id=1`

其返回数据:
```json
{
    "id": 1,
    "name": "asset001",
    "desc": "测试资产001"
}
```

### 4.1.1 500用户5000RPS
测试压力数据:
- 模拟用户线程数 : 500
- 模拟RPS : 5000
- 运行时间 : 140秒

测试期间容器的CPU消耗: 100%
> 通过命令`docker stats --format "table {{.Name}}\t{{.CPUPerc}}\t{{.MemUsage}}"`监视。

测试期间客户机资源消耗情况: CPU/内存/网络流量均未到上限。
> 通过客户机的系统监视器监视。

测试结果:

| Label | # Samples | Average | Median | 90% Line | 95% Line | 99% Line | Min | Max | Error % | Throughput | Received KB/sec | Sent KB/sec |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| HTTP Request asset_query | 554587 | 2 | 1 | 3 | 4 | 17 | 0 | 1048 | 0.000% | 4622.17462 | 785.41 | 0.00 |
| TOTAL | 554587 | 2 | 1 | 3 | 4 | 17 | 0 | 1048 | 0.000% | 4622.17462 | 785.41 | 0.00 |


### 4.1.2 1000用户10000RPS
测试压力数据:
- 模拟用户线程数 : 1000
- 模拟RPS : 10000
- 运行时间 : 140秒

测试期间容器的CPU消耗: 160%

测试期间客户机资源消耗情况: CPU/内存/网络流量均未到上限。

测试结果:

| Label | # Samples | Average | Median | 90% Line | 95% Line | 99% Line | Min | Max | Error % | Throughput | Received KB/sec | Sent KB/sec |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| HTTP Request asset_query | 1219074 | 8 | 1 | 5 | 14 | 85 | 0 | 3086 | 0.000% | 8709.91112 | 1480.00 | 0.00 |
| TOTAL | 1219074 | 8 | 1 | 5 | 14 | 85 | 0 | 3086 | 0.000% | 8709.91112 | 1480.00 | 0.00 |


### 4.1.3 1000用户100000RPS
测试压力数据:
- 模拟用户线程数 : 1000
- 模拟RPS : 100000
- 运行时间 : 140秒

测试期间容器的CPU消耗: 220%

测试期间客户机资源消耗情况: CPU/内存/网络流量均未到上限。

测试结果:

| Label | # Samples | Average | Median | 90% Line | 95% Line | 99% Line | Min | Max | Error % | Throughput | Received KB/sec | Sent KB/sec |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| HTTP Request asset_query | 3973113 | 30 | 23 | 62 | 91 | 151 | 0 | 3152 | 0.000% | 28386.47519 | 4823.48 | 0.00 |
| TOTAL | 3973113 | 30 | 23 | 62 | 91 | 151 | 0 | 3152 | 0.000% | 28386.47519 | 4823.48 | 0.00 |


## 4.2 web-pm-java-asset_query
该接口完整URL : `http://hostname:18081/asset/query?id=1`

其返回数据:
```json
{
    "id": 1,
    "name": "asset001",
    "desc": "测试资产001"
}
```

### 4.2.1 500用户5000RPS
测试压力数据:
- 模拟用户线程数 : 500
- 模拟RPS : 5000
- 运行时间 : 140秒

测试期间容器的CPU消耗: 150%

测试期间客户机资源消耗情况: CPU/内存/网络流量均未到上限。

测试结果:

| Label | # Samples | Average | Median | 90% Line | 95% Line | 99% Line | Min | Max | Error % | Throughput | Received KB/sec | Sent KB/sec |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| HTTP Request asset_query | 605996 | 7 | 2 | 11 | 20 | 56 | 0 | 3050 | 0.000% | 4329.71807 | 896.38 | 0.00 |
| TOTAL | 605996 | 7 | 2 | 11 | 20 | 56 | 0 | 3050 | 0.000% | 4329.71807 | 896.38 | 0.00 |


### 4.2.2 1000用户10000RPS
测试压力数据:
- 模拟用户线程数 : 1000
- 模拟RPS : 10000
- 运行时间 : 140秒

测试期间容器的CPU消耗: 210%

测试期间客户机资源消耗情况: CPU/内存/网络流量均未到上限。

测试结果:

| Label | # Samples | Average | Median | 90% Line | 95% Line | 99% Line | Min | Max | Error % | Throughput | Received KB/sec | Sent KB/sec |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| HTTP Request asset_query | 1217576 | 21 | 7 | 32 | 53 | 228 | 0 | 7157 | 0.000% | 8699.33268 | 1801.03 | 0.00 |
| TOTAL | 1217576 | 21 | 7 | 32 | 53 | 228 | 0 | 7157 | 0.000% | 8699.33268 | 1801.03 | 0.00 |


### 4.2.3 1000用户100000RPS
测试压力数据:
- 模拟用户线程数 : 1000
- 模拟RPS : 100000
- 运行时间 : 140秒

测试期间容器的CPU消耗: 270%

测试期间客户机资源消耗情况: CPU/内存/网络流量均未到上限。

测试结果:

| Label | # Samples | Average | Median | 90% Line | 95% Line | 99% Line | Min | Max | Error % | Throughput | Received KB/sec | Sent KB/sec |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| HTTP Request asset_query | 2213638 | 54 | 55 | 77 | 89 | 121 | 0 | 1511 | 0.000% | 15815.99291 | 3273.64 | 0.00 |
| TOTAL | 2213638 | 54 | 55 | 77 | 89 | 121 | 0 | 1511 | 0.000% | 15815.99291 | 3273.64 | 0.00 |

## 4.3 web-pm-quarkus-asset_query
该接口完整URL : `http://hostname:18082/asset/query?id=1`

其返回数据:
```json
{
    "id": 1,
    "name": "asset001",
    "desc": "测试资产001"
}
```

## 4.3.1 1000用户100000RPS
测试压力数据:
- 模拟用户线程数 : 1000
- 模拟RPS : 100000
- 运行时间 : 140秒

测试期间容器的CPU消耗: 290%

测试期间客户机资源消耗情况: CPU/内存/网络流量均未到上限。

测试结果:

| Label | # Samples | Average | Median | 90% Line | 95% Line | 99% Line | Min | Max | Error % | Throughput | Received KB/sec | Sent KB/sec |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| HTTP Request asset_query | 2641279 | 45 | 17 | 124 | 160 | 261 | 0 | 1426 | 0.000% | 18878.81950 | 2507.34 | 0.00 |
| TOTAL | 2641279 | 45 | 17 | 124 | 160 | 261 | 0 | 1426 | 0.000% | 18878.81950 | 2507.34 | 0.00 |



# 五、单表读写API性能测试
本节测试带有单表读写操作的HttpAPI接口，没有额外添加拦截器或过滤器。
- web-pm-go : "/account/add"、"/account/query"
- web-pm-java : "/account/add"、"/account/query"

从结果上看，**高并发场景下的单表读写HttpAPI，在服务器硬件、数据库配置相同的条件下，相比java+springboot+mybatis，go+gin+gorm无论是响应时间、吞吐量，还是资源消耗，都要明显胜出。**
- CPU使用率上，`web-pm-go`比`web-pm-java`少`50%~130%`。
- 响应时间上，`web-pm-go`优势明显，以响应时间中位数来看，`web-pm-java`是`web-pm-go`的2到3倍。
- 吞吐量上，`web-pm-go`也占据比较明显的优势。

在`500模拟用户并发 + 每秒5000次请求`的并发压力下，双方的单表读写的性能表现如下所示：

| 项目 | 接口 | 容器CPU使用率 | MySQL CPU使用率 | 响应时间中位数 | 吞吐量 |
| --- | --- | --- | --- | --- | --- |
| web-pm-go | /account/add | 100% | 150% | 85ms | 1939 |
| web-pm-java | /account/add | 150% | 120% | 182ms | 1698 |
| web-pm-go | /account/query | 130% | 150% | 44ms | 4128 |
| web-pm-java | /account/query | 260% | 70% | 137ms | 2785 |

而在`500模拟用户并发 + 每秒1万次请求`的并发压力下，双方的单表读写的性能表现如下所示：

| 项目 | 接口 | 容器CPU使用率 | MySQL CPU使用率 | 响应时间中位数 | 吞吐量 |
| --- | --- | --- | --- | --- | --- |
| web-pm-go | /account/add | 100% | 150% | 78ms | 2137 |
| web-pm-java | /account/add | 150% | 130% | 168ms | 1776 |
| web-pm-quarkus | /account/add | 140% | 120% | 194ms | 1935 |
| web-pm-go | /account/query | 130% | 160% | 45ms | 4634 |
| web-pm-java | /account/query | 210% | 100% | 101ms | 3713 |
| web-pm-quarkus | /account/query | 180% | 130% | 126ms | 3396 |


## 5.1 测试计划
`web-pm-go`与`web-pm-java`连接同一个数据库，使用同一张表；该数据库部署在同一个服务器上。

相关测试计划:
- `jmeter/web-pm-go-account_add/web-pm-go-account_add.jmx` : 测试`web-pm-go`的`/account/add`接口
- `jmeter/web-pm-go-account_query/web-pm-go-account_query.jmx` : 测试`web-pm-go`的`/account/query`接口
- `jmeter/web-pm-java-account_add/web-pm-java-account_add.jmx` : 测试`web-pm-java`的`/account/add`接口
- `jmeter/web-pm-java-account_query/web-pm-java-account_query.jmx` : 测试`web-pm-java`的`/account/query`接口

测试计划的执行步骤如下：
1. 删除表`accounts`，并重建该表，参考`db/drop_create_table.sql`
2. 执行`jmeter/web-pm-go-account_add/web-pm-go-account_add.jmx`
3. 执行`jmeter/web-pm-go-account_query/web-pm-go-account_query.jmx`
4. 执行`jmeter/web-pm-java-account_query/web-pm-java-account_query.jmx`
5. 删除表`accounts`，并重建该表，参考`db/drop_create_table.sql`
6. 执行`jmeter/web-pm-java-account_add/web-pm-java-account_add.jmx`

## 5.2 web-pm-go的add与query
本节记录`web-pm-go`的`/account/add`和`/account/query`接口的测试结果。

连接池最大连接数: 100
> 由于mysql服务也部署在相同服务器上，且该服务器CPU只有4核，磁盘只有1块，因此连接池最大连接数设置到100实际上可能反而会导致性能下降。但本次测试目的是对比go和java的web框架的性能表现，数据库以及连接池方面，确保条件相同即可。

### 5.2.1 web-pm-go-account_add
接口完整URL : `http://hostname:18080/account/add`

Http Method : `POST`

Body参数(application/json): 
```
{
    "actName": "libai",
    "actPwd": "libai@DATANG",
    "actNickName": "诗仙太白",
    "actIntroduction": "李白，唐朝诗人，字太白，号青莲居士，世称诗仙。",
    "actStatus": 0
}
```

响应数据:
```json
{
    "resCd": "1",
    "resMsg": "新增帐户ID: xx"
}
```

#### 500用户5000RPS
测试压力数据:
- 模拟用户线程数 : 500
- 模拟RPS : 5000
- 运行时间 : 140秒

测试期间容器的CPU使用率 : 100%

测试期间mysql的CPU使用率 : 150%

测试期间mysql连接数 : 100

插入数据件数 : 271408

测试结果:

| Label | # Samples | Average | Median | 90% Line | 95% Line | 99% Line | Min | Max | Error % | Throughput | Received KB/sec | Sent KB/sec |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| HTTP Request account_add | 271408 | 218 | 85 | 323 | 587 | 3077 | 3 | 12950 | 0.000% | 1939.18262 | 321.16 | 0.00 |
| TOTAL | 271408 | 218 | 85 | 323 | 587 | 3077 | 3 | 12950 | 0.000% | 1939.18262 | 321.16 | 0.00 |

#### 500用户10000RPS
测试压力数据:
- 模拟用户线程数 : 500
- 模拟RPS : 10000
- 运行时间 : 140秒

测试期间容器的CPU使用率 : 100%

测试期间mysql的CPU使用率 : 150%

测试期间mysql连接数 : 100

插入数据件数 : 299056

测试结果:

| Label | # Samples | Average | Median | 90% Line | 95% Line | 99% Line | Min | Max | Error % | Throughput | Received KB/sec | Sent KB/sec |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| HTTP Request account_add | 299056 | 200 | 78 | 291 | 506 | 2633 | 3 | 12537 | 0.000% | 2136.67898 | 353.95 | 0.00 |
| TOTAL | 299056 | 200 | 78 | 291 | 506 | 2633 | 3 | 12537 | 0.000% | 2136.67898 | 353.95 | 0.00 |


#### 分析
1. 容器的CPU使用率与Mysql服务的CPU使用率之和距离`400%`(服务器CPU为4核)尚有一段余地，可见CPU并未打满，此时应当是写入操作IO阻塞成为性能瓶颈。
2. 在5000RPS和1万RPS的性能压力下，`web-pm-go-account_add`的吞吐量为`1900+`和`2136+`，响应时间中位数为`85ms`和`78ms`。
3. 在140秒内，`web-pm-go-account_add`共新增数据`271408`条和`299056`条。


### 5.2.2 web-pm-go-account_query
接口完整URL : `http://hostname:18080/account/query?id=100`

Http Method : `GET`

响应数据:
```json
{
    "ID": 100,
    "CreatedAt": "2022-12-22T12:12:03.106+08:00",
    "UpdatedAt": "2022-12-22T12:12:03.106+08:00",
    "DeletedAt": null,
    "actName": "libai",
    "actPwd": "libai@DATANG",
    "actNickName": "诗仙太白",
    "actIntroduction": "李白，唐朝诗人，字太白，号青莲居士，世称诗仙。",
    "actStatus": 0,
    "actRegisterDate": "2022-12-22T12:12:03.105+08:00"
}
```

#### 500用户5000RPS
测试压力数据:
- 模拟用户线程数 : 500
- 模拟RPS : 5000
- 运行时间 : 140秒

测试期间容器的CPU使用率 : 130%

测试期间mysql的CPU使用率 : 150%

测试期间mysql连接数 : 100

单表件数 : 271408

测试结果:

| Label | # Samples | Average | Median | 90% Line | 95% Line | 99% Line | Min | Max | Error % | Throughput | Received KB/sec | Sent KB/sec |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| HTTP Request account_add | 577803 | 86 | 44 | 158 | 260 | 931 | 0 | 4327 | 0.000% | 4128.34381 | 1870.66 | 0.00 |
| TOTAL | 577803 | 86 | 44 | 158 | 260 | 931 | 0 | 4327 | 0.000% | 4128.34381 | 1870.66 | 0.00 |

#### 500用户10000RPS
测试压力数据:
- 模拟用户线程数 : 500
- 模拟RPS : 10000
- 运行时间 : 140秒

测试期间容器的CPU使用率 : 130%

测试期间mysql的CPU使用率 : 160%

测试期间mysql连接数 : 100

单表件数 : 248611

测试结果:

| Label | # Samples | Average | Median | 90% Line | 95% Line | 99% Line | Min | Max | Error % | Throughput | Received KB/sec | Sent KB/sec |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| HTTP Request account_add | 648550 | 90 | 45 | 162 | 273 | 1046 | 0 | 4470 | 0.000% | 4633.82395 | 2063.50 | 0.00 |
| TOTAL | 648550 | 90 | 45 | 162 | 273 | 1046 | 0 | 4470 | 0.000% | 4633.82395 | 2063.50 | 0.00 |


#### 分析
1. mysql的CPU使用率依然在`150%`左右，而容器的CPU使用率上升到`130%`，这应该是因为查询SQL利用了MySQL缓存从而极大缓解了数据库读的IO阻塞，从而促使容器CPU使用率上升。但注意此时容器和MySQL的CPU使用率依然距离`400%`有一段距离，因此大约可以知道MySQL的CPU使用并未受容器CPU使用率上升影响。
2. 在5000RPS与1万RPS的性能压力下，`web-pm-go-account_query`的吞吐量分别为`4128+`和`4633+`，响应时间中位数为`44ms`和`45ms`。吞吐量并未比简单API的吞吐量下降太多，主要是由于查询SQL利用了MySQL缓存，极大缓解了IO阻塞。


## 5.3 web-pm-java的add与query
本节记录`web-pm-java`的`/account/add`和`/account/query`接口的测试结果。

连接池最大连接数: 100
> 由于mysql服务也部署在相同服务器上，且该服务器CPU只有4核，磁盘只有1块，因此连接池最大连接数设置到100实际上可能反而会导致性能下降。但本次测试目的是对比go和java的web框架的性能表现，数据库以及连接池方面，确保条件相同即可。


### 5.3.1 web-pm-java-account_add
接口完整URL : `http://hostname:18081/account/add`

Http Method : `POST`

Body参数(application/json): 
```
{
    "actName": "libai",
    "actPwd": "libai@DATANG",
    "actNickName": "诗仙太白",
    "actIntroduction": "李白，唐朝诗人，字太白，号青莲居士，世称诗仙。",
    "actStatus": 0
}
```

响应数据:
```json
{
    "resCd": "1",
    "resMsg": "新增帐户ID: xx"
}
```

#### 500用户5000RPS
测试压力数据:
- 模拟用户线程数 : 500
- 模拟RPS : 5000
- 运行时间 : 140秒

测试期间容器的CPU使用率 : 150%

测试期间mysql的CPU使用率 : 120%

测试期间mysql连接数 : 100

插入数据件数 : 239747

测试结果:

| Label | # Samples | Average | Median | 90% Line | 95% Line | 99% Line | Min | Max | Error % | Throughput | Received KB/sec | Sent KB/sec |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| HTTP Request account_add | 239747 | 254 | 182 | 366 | 489 | 932 | 11 | 9039 | 0.000% | 1698.43013 | 342.18 | 0.00 |
| TOTAL | 239747 | 254 | 182 | 366 | 489 | 932 | 11 | 9039 | 0.000% | 1698.43013 | 342.18 | 0.00 |


#### 500用户10000RPS
测试压力数据:
- 模拟用户线程数 : 500
- 模拟RPS : 10000
- 运行时间 : 140秒

测试期间容器的CPU使用率: 150%

测试期间mysql的CPU使用率: 130%

测试期间mysql连接数 : 100

插入数据件数: 248611

测试结果:

| Label | # Samples | Average | Median | 90% Line | 95% Line | 99% Line | Min | Max | Error % | Throughput | Received KB/sec | Sent KB/sec |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| HTTP Request account_add | 248611 | 241 | 168 | 334 | 461 | 868 | 3 | 13108 | 0.000% | 1776.28768 | 357.88 | 0.00 |
| TOTAL | 248611 | 241 | 168 | 334 | 461 | 868 | 3 | 13108 | 0.000% | 1776.28768 | 357.88 | 0.00 |

#### 分析
1. 容器的CPU使用率相比`web-pm-go`要多`50%`，而MySQL的CPU使用率反而下降了`20~30%`，两者之和依然距离`400%`有一段距离。推测是`web-pm-java`在高并发时吞吐量的下降导致打给MySQL的数据变少，进而导致MySQL并不需要满载运转，因而其CPU使用率下降。
2. 在5000RPS和1万RPS的性能压力下，`web-pm-java-account_add`的吞吐量为`1698+`和`1776+`，响应时间中位数为`182ms`和`168ms`。相比`web-pm-go`，吞吐量有所下降，响应时间明显更久。
3. 在140秒内，`web-pm-java-account_add`共新增数据`239747`和`248611`条。比`web-pm-go`少了约3～5万件。


### 5.3.2 web-pm-java-account_query
接口完整URL : `http://hostname:18081/account/query?id=101`

Http Method : `GET`

响应数据:
```json
{
    "id": 101,
    "createdAt": "2022-12-23T10:39:09.568",
    "updatedAt": "2022-12-23T10:39:09.568",
    "deletedAt": null,
    "actName": "libai",
    "actPwd": "libai@DATANG",
    "actNickName": "诗仙太白",
    "actIntroduction": "李白，唐朝诗人，字太白，号青莲居士，世称诗仙。",
    "actStatus": 0,
    "actRegisterDate": "2022-12-23T10:39:09.567"
}
```

#### 500用户5000RPS
测试压力数据:
- 模拟用户线程数 : 500
- 模拟RPS : 5000
- 运行时间 : 140秒

测试期间容器的CPU使用率 : 260%

测试期间mysql的CPU使用率 : 70%

测试期间mysql连接数 : 100

单表件数 : 271408

测试结果:

| Label | # Samples | Average | Median | 90% Line | 95% Line | 99% Line | Min | Max | Error % | Throughput | Received KB/sec | Sent KB/sec |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| HTTP Request account_add | 389823 | 146 | 137 | 242 | 295 | 481 | 0 | 2143 | 0.000% | 2784.68869 | 1312.94 | 0.00 |
| TOTAL | 389823 | 146 | 137 | 242 | 295 | 481 | 0 | 2143 | 0.000% | 2784.68869 | 1312.94 | 0.00 |

#### 500用户10000RPS
测试压力数据:
- 模拟用户线程数 : 500
- 模拟RPS : 10000
- 运行时间 : 140秒

测试期间容器的CPU使用率: 210%

测试期间mysql的CPU使用率: 100%

测试期间mysql连接数 : 100

单表件数: 248611

测试结果:

| Label | # Samples | Average | Median | 90% Line | 95% Line | 99% Line | Min | Max | Error % | Throughput | Received KB/sec | Sent KB/sec |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| HTTP Request account_add | 519687 | 113 | 101 | 182 | 227 | 412 | 0 | 4154 | 0.000% | 3713.16395 | 1721.67 | 0.00 |
| TOTAL | 519687 | 113 | 101 | 182 | 227 | 412 | 0 | 4154 | 0.000% | 3713.16395 | 1721.67 | 0.00 |


#### 分析
1. 容器的CPU使用率高达`260%`和`210%`，可以看到明显影响到了MySQL的CPU使用率，使其下降到`70%`和`100%`。此时MySQL明显没有满负荷运行，这应该会明显影响到吞吐量。查询SQL重复，可以一直使用MySQL缓存，导致性能压力从数据库读取IO阻塞向`web-pm-java`容器服务转移，于是容器的CPU使用率非常高，以至于抢夺了MySQL的CPU使用，使得数据库读取的吞吐量明显下降。
2. 在5000RPS和1万RPS的性能压力下，`web-pm-java-account_query`的吞吐量为`2784+`和`3713+`，响应时间中位数为`137ms`和`101ms`。相比`web-pm-go`，不管是吞吐量还是响应时间都明显不如。


## 5.4 web-pm-quarkus的add与query


### 5.3.1 web-pm-quarkus-account_add

#### 500用户10000RPS
测试压力数据:
- 模拟用户线程数 : 500
- 模拟RPS : 10000
- 运行时间 : 140秒

测试期间容器的CPU使用率: 140%

测试期间mysql的CPU使用率: 120%

测试期间mysql连接数 : 100

插入件数: 270858

测试结果:

| Label | # Samples | Average | Median | 90% Line | 95% Line | 99% Line | Min | Max | Error % | Throughput | Received KB/sec | Sent KB/sec |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| HTTP Request account_add | 270858 | 224 | 194 | 277 | 312 | 523 | 3 | 9547 | 0.000% | 1935.19762 | 246.79 | 0.00 |
| TOTAL | 270858 | 224 | 194 | 277 | 312 | 523 | 3 | 9547 | 0.000% | 1935.19762 | 246.79 | 0.00 |


### 5.3.2 web-pm-quarkus-account_query

#### 500用户10000RPS
测试压力数据:
- 模拟用户线程数 : 500
- 模拟RPS : 10000
- 运行时间 : 140秒

测试期间容器的CPU使用率: 180%

测试期间mysql的CPU使用率: 130%

测试期间mysql连接数 : 100

单表件数: 270858

测试结果:

| Label | # Samples | Average | Median | 90% Line | 95% Line | 99% Line | Min | Max | Error % | Throughput | Received KB/sec | Sent KB/sec |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| HTTP Request account_add | 475339 | 124 | 126 | 178 | 200 | 244 | 1 | 879 | 0.000% | 3396.20040 | 1200.61 | 0.00 |
| TOTAL | 475339 | 124 | 126 | 178 | 200 | 244 | 1 | 879 | 0.000% | 3396.20040 | 1200.61 | 0.00 |


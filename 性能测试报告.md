性能测试报告
=====

# 一、概述
对以下项目执行相同硬件环境下相同的压力测试(jmeter):
- `web-pm-dotnet` : dotnet WEB测试项目, 无额外的性能调优措施
- `web-pm-gin` : go+gin+gorm WEB测试项目, 无额外的性能调优措施
- `web-pm-quarkus` : kotlin+quarkus+hibernate WEB测试项目, 无额外的性能调优措施
- `web-pm-rust` : rust WEB测试项目, 无额外的性能调优措施
- `web-pm-springboot` : java+springboot+mybatis WEB测试项目, 无额外的性能调优措施
- `web-pm-vertx` : kotlin+vertx WEB测试项目, 无额外的性能调优措施


注意:
1. 应用服务、数据库和jmeter都在一台机器(i7-12700H + 32G 内存 + 1T SSD)上。
2. 数据库为MySQL8.0.22社区版，docker容器，关闭了binlog。
3. 各应用服务的数据库连接池最大连接数统一为100。
4. 各应用服务均未做额外的性能调优。其中springboot只显式设置了tomcat线程池配置，但均为默认配置(如最大线程数为200)。vertx设置了web请求监听Verticle的实例数量为当前平台CPU的processor数量。(vertx默认只有一个Verticle实例，此时性能表现实在过于拉胯。)
5. 应用服务均直接命令行启动，并未使用docker部署。
6. `web-pm-vertx`提供了jar包和native两种部署方式，分别是`web-pm-vertx-jar`和`web-pm-vertx-native`。
7. `web-pm-quarkus`只测试了jar包部署方式。


从结果能看出来：
1. vertx/quarkus这样的反应式编程框架在高并发环境下的IO密集型应用中具备较大优势，能够用更少的CPU提供更高的并发能力，并且偏差更小，意味着增加硬件能带来更线性的性能提升。
2. 目前使用graalVM社区版编译的native应用，可能会受到SerialGC的拖累导致性能表现下降，甚至不如充分热机后的JVM。graalVM社区版目前的优势应该还是在启动速度以及内存占用上，也就是FaaS方面有优势。
3. go+gin+gorm是一套性能表现稳定的框架，在本次测试中，虽然比不上vertx，但各项测试成绩也都比较优秀，很稳定。
4. springboot在硬件相对较好时，默认的线程池配置也可获得不错的性能表现。
5. dotnet、rust的表现不尽如人意，可能还是我们的代码没有找到正确的实现方式，或者需要一点额外的调优配置。


# 二、性能表现汇总

## 2.1 单表插入API表现汇总
5000个并发线程不断调用`/account/add`接口向`accounts`表插入一条数据，持续3分钟，每个项目都执行3轮，取其吞吐量最高的一次。


| Label | # 样本 | 平均值 | 中位数 | 90% 百分位 | 95% 百分位 | 99% 百分位 | 最小值 | 最大值 | 异常 % | 吞吐量 | 接收 KB/sec | 标准偏差 | CPU使用率 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| web-pm-dotnet | 1188585 | 738 | 735 | 801 | 847 | 877 | 10 | 3300 | 0.00% | 6580.4 | 1247.1 | 81.22 | 81% |
| web-pm-gin | 4578866 | 193 | 19 | 1333 | 1530 | 1644 | 0 | 4861 | 0.00% | 24933.5 | 4160.3 | 467.98 | 81% |
| web-pm-quarkus | 5084149 | 174 | 174 | 197 | 208 | 297 | 1 | 1226 | 0.00% | 27603.8 | 3552.4 | 37.82 | 80% |
| web-pm-rust | 3631520 | 244 | 17 | 42 | 452 | 7730 | 0 | 31882 | 0.00% | 19111.7 | 2887.2 | 1576.44 | 62% |
| web-pm-springboot | 4461227 | 199 | 250 | 273 | 284 | 388 | 0 | 1316 | 0.00% | 24121.0 | 4892.9 | 109.51 | 83% |
| web-pm-vertx-jar | 5007309 | 175 | 153 | 198 | 365 | 654 | 1 | 1739 | 0.00% | 27661.3 | 3181.5 | 101.34 | 80% |
| web-pm-vertx-native | 3863130 | 228 | 190 | 363 | 519 | 676 | 1 | 1441 | 0.00% | 21121.9 | 2428.0 | 120.20 | 65% |


这里表现最好的是`web-pm-vertx-jar`和`web-pm-quarkus`，然后是`web-pm-gin`和`web-pm-springboot`。

`web-pm-dotnet`的表现不尽如人意。可能还是我们的代码没有找到正确的实现方式，或者需要一点额外的调优配置。

更具体的测试数据可参考: 
```
jmeter/*-account_add/5000_3m_*_aggregate.csv
jmeter/*-account_add/5000_3m_*_monitor_report.png
```

## 2.2 1000件全表查询API表现汇总
5000个并发线程不断调用`/account/list`接口对`accounts`表执行全表查询，持续3分钟，每个项目都执行3轮，取其吞吐量最高的一次。
> `accounts`表此时全表件数为1000件。

| Label | # 样本 | 平均值 | 中位数 | 90% 百分位 | 95% 百分位 | 99% 百分位 | 最小值 | 最大值 | 异常 % | 吞吐量 | 接收 KB/sec | 标准偏差 | CPU使用率 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| web-pm-dotnet | 197610 | 4489 | 4630 | 4863 | 4921 | 5031 | 10 | 5319 | 0.00% | 1070.4 | 325134.7 | 704.22 | 82% |
| web-pm-gin | 332765 | 2699 | 222 | 1036 | 2556 | 118036 | 7 | 180911 | 0.00% | 1785.3 | 594567.7 | 17834.57 | 91% |
| web-pm-quarkus | 315859 | 2851 | 2947 | 3048 | 3084 | 3164 | 5 | 3912 | 0.00% | 1686.2 | 512082.3 | 461.94 | 80% |
| web-pm-rust | 196890 | 4782 | 812 | 901 | 945 | 130768 | 8 | 222087 | 1.31% | 805.5 | 241463.3 | 21814.27 | 30% |
| web-pm-springboot | 296372 | 3057 | 1203 | 9322 | 10764 | 11636 | 5 | 23878 | 0.00% | 1321.0 | 416746.7 | 3649.36 | 86% |
| web-pm-vertx-jar | 473477 | 1906 | 1998 | 2082 | 2108 | 2165 | 3 | 2748 | 0.00% | 2481.9 | 809442.3 | 368.31 | 85% |
| web-pm-vertx-native | 94082 | 9622 | 10638 | 11223 | 11396 | 11695 | 8 | 12646 | 0.00% | 491.0 | 160132.2 | 2495.68 | 30% |


这里表现最好的是`web-pm-vertx-jar`，其次是`web-pm-gin`。
> vertx没有orm功能，数据库返回的数据直接转为jsonObject，底层是LinkedHashMap，然后转为json字符串返回。而其他框架有正儿八经的ORM功能，会先映射到PO或者struct里，然后再转为json字符串返回。这一点导致vertx在这个接口的测试上占有较大优势，vertx提高性能表现的一个思路就是这种空间换时间的做法。
> 
> 但实际的业务场景中，如果不方便直接使用jsonObject，或者不愿意用空间换时间，而是需要转为PO的话，那么多出的转换操作会降低vertx的性能表现，反应式编程仍然会保证它在高并发时依然有性能优势，但可能就不会有这么大的优势了，具体要取决于转换PO的效率。

`web-pm-vertx-native`表现拉胯，它的native编译使用的是社区版的graalVM，再加上正好这个接口在高并发调用时确实会快速大量分配内存，这就很难让人不怀疑是社区版graalVM只支持SerialGC的锅了。。。

更具体的测试数据可参考: 
```
jmeter/*-account_list/5000_3m_*_aggregate.csv
jmeter/*-account_list/5000_3m_*_monitor_report.png
```


## 2.3 主键查询API表现汇总
5000个并发线程不断调用`/account/query`接口对`accounts`表执行主键查询，持续3分钟，每个项目都执行3轮，取其吞吐量最高的一次。
> `accounts`表此时全表件数为1000件。

| Label | # 样本 | 平均值 | 中位数 | 90% 百分位 | 95% 百分位 | 99% 百分位 | 最小值 | 最大值 | 异常 % | 吞吐量 | 接收 KB/sec | 标准偏差 | CPU使用率 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| web-pm-dotnet | 1580098 | 559 | 518 | 928 | 1014 | 1243 | 1 | 7697 | 0.00% | 8608.2 | 3850.1 | 277.20 | 54% |
| web-pm-gin | 7486008 | 118 | 20 | 732 | 780 | 836 | 0 | 3858 | 0.00% | 40765.9 | 18411.8 | 255.16 | 81% |
| web-pm-quarkus | 6798730 | 130 | 131 | 141 | 159 | 262 | 0 | 827 | 0.00% | 37002.7 | 14309.6 | 33.66 | 77% |
| web-pm-rust | 5689415 | 157 | 22 | 27 | 28 | 4065 | 0 | 131201 | 0.00% | 24512.9 | 10030.9 | 1453.94 | 64% |
| web-pm-springboot | 8070512 | 110 | 137 | 166 | 269 | 408 | 0 | 3671 | 0.00% | 43006.5 | 20285.3 | 96.43 | 88% |
| web-pm-vertx-jar | 7894738 | 112 | 111 | 149 | 237 | 342 | 0 | 1153 | 0.00% | 42952.9 | 16988.2 | 59.96 | 77% |
| web-pm-vertx-native | 6024186 | 146 | 141 | 181 | 286 | 317 | 0 | 695 | 0.00% | 32959.8 | 13035.8 | 54.22 | 68% |


这里`web-pm-springboot`, `web-pm-vertx-jar`, `web-pm-gin`的表现都很好，其他的都有一些差距，尤其`web-pm-dotnet`很拉胯，可能还是我们的代码没有找到正确的实现方式，或者需要一点额外的调优配置。

更具体的测试数据可参考: 
```
jmeter/*-account_query/5000_3m_*_aggregate.csv
jmeter/*-account_query/5000_3m_*_monitor_report.png
```


## 2.4 内存读取API表现汇总
5000个并发线程不断调用`/asset/query`接口，直接从内存返回一条数据，持续3分钟，每个项目都执行3轮，取其吞吐量最高的一次。


| Label | # 样本 | 平均值 | 中位数 | 90% 百分位 | 95% 百分位 | 99% 百分位 | 最小值 | 最大值 | 异常 % | 吞吐量 | 接收 KB/sec | 标准偏差 | CPU使用率 |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| web-pm-dotnet | 13920690 | 63 | 1 | 210 | 297 | 436 | 0 | 3326 | 0.00% | 76058.1 | 14780.8 | 115.13 | 80% |
| web-pm-gin | 13677288 | 64 | 8 | 312 | 351 | 417 | 0 | 1542 | 0.00% | 75355.7 | 12804.6 | 124.68 | 62% |
| web-pm-quarkus | 18946809 | 46 | 0 | 165 | 233 | 447 | 0 | 747 | 0.00% | 103953.1 | 13806.3 | 92.99 | 76% |
| web-pm-rust | 22852510 | 40 | 0 | 6 | 23 | 481 | 0 | 131228 | 0.01% | 110346.9 | 17147.6 | 1409.76 | 52% |
| web-pm-springboot | 15935702 | 55 | 6 | 186 | 260 | 434 | 0 | 17799 | 0.00% | 87420.0 | 18098.7 | 131.76 | 79% |
| web-pm-vertx-jar | 16648805 | 53 | 1 | 165 | 264 | 445 | 0 | 743 | 0.00% | 91360.5 | 10884.7 | 94.60 | 70% |
| web-pm-vertx-native | 15587216 | 56 | 4 | 172 | 282 | 464 | 0 | 960 | 0.00% | 85594.7 | 10197.8 | 99.90 | 72% |


这里rust表现最好，其他的也不差。

更具体的测试数据可参考: 
```
jmeter/*-asset_query/5000_3m_*_aggregate.csv
jmeter/*-asset_query/5000_3m_*_monitor_report.png
```

# 三、测试环境
本章节用于记述测试资源与思路。

## 3.1 测试机(物理机)资源
- CPU : 12th Gen Intel(R) Core(TM) i7-12700H
- 内存 : 32G
- 磁盘 : SSD 1T
- OS : Linux Mint 20.3
- jmeter : 5.1.1

## 3.2 语言、框架与工具的版本
语言、框架与工具及其版本信息如下：
- golang版本 : v1.17.5
- gin版本 : v1.8.1
- gorm版本 : v1.24.2
- java版本 : openJDK-17.0.3
- springboot版本 : 3.0.0
- mybatis-spring-boot-starter版本 : 3.0.1
- kotlin版本 : 1.7.21
- quarkus版本 : 2.15.1.Final
- hibernate版本 : 5.6.14.Final
- vertx版本 : 4.3.7
- JMeter版本 : 5.1.1
- dotnet版本 : 6.0.404
- rust版本 : 1.66.0




